<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NYC Vibes JS</title>
    <script src="https://unpkg.com/kaboom@3000/dist/kaboom.js"></script>
    <script src="constants.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
        }
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
<script>
console.log("Script started!"); // Debug log to verify script execution

// ================================
// 0. GAME CONSTANTS
// ================================

// ================================
// 1. INITIALIZE GAME
// ================================

kaboom({
    width: 1024,  // Increased from 800
    height: 768,  // Increased from 600
    background: [0, 0, 0],
    crisp: true,  // Enable crisp rendering
    pixelDensity: 1,  // Disable high DPI scaling
});

console.log("Kaboom initialized!"); // Debug log to verify Kaboom is running

// ================================
// 2. LOAD ASSETS
// ================================

loadSprite("start", "static/start_screen.jpg");
console.log("Start screen sprite loaded!"); // Debug log to verify asset loading

loadSprite("player", "static/KJK.png");
console.log("Player sprite loaded!"); // Debug log to verify asset loading

loadSprite("map", "static/NYCmap.jpg");
console.log("Map sprite loaded!"); // Debug log to verify asset loading

loadSound("bgm", "static/bg_music.mp3");
console.log("Background music loaded!"); // Debug log to verify asset loading

loadSound("positive", "static/positive.wav");
console.log("Positive sound loaded!"); // Debug log to verify asset loading

loadSound("negative", "static/negative.wav");
console.log("Negative sound loaded!"); // Debug log to verify asset loading

// Item sprites
const itemSprites = [
    "dog", "poop", "pizza", "pretzel", "bagels", "coffee",
    "museum", "tourist", "edible", "grenade", "sun",
    "construction", "rain", "taxi", "subway"
];
for (const spriteName of itemSprites) {
    loadSprite(spriteName, `static/${spriteName}.png`);
}

// ================================
// 3. CUTE MESSAGES
// ================================

const cuteMessages = {
    pizza: "Nothing better than NYC pizza! +5",
    dog: "Who's a good dog? +4",
    pretzel: "Twist and shout! Pretzel +4",
    bagels: "Bagels from NYC are unbeatable! +3",
    coffee: "Fuel for the city grind! +5",
    poop: "Watch your step! Gross! -5",
    museum: "Discovered a hidden gem! +5",
    tourist: "Tourist jam! -4",
    edible: "Feeling funny... +5",
    grenade: "Grenade ready! 0",
    sun: "Sunshine boost activated!",
    construction: "Detour ahead! -3",
    rain: "Rainy day blues. -4",
    taxi: "Caught a cab! +2",
    subway: "Next stop, fun! +2",
};

// Master item list
const itemsToSpawn = [
    { name: "pizza", points: 5 },
    { name: "pretzel", points: 4 },
    { name: "bagels", points: 3 },
    { name: "coffee", points: 5 },
    { name: "museum", points: 5 },
    { name: "tourist", points: -4 },
    { name: "edible", points: 5 },
    { name: "grenade", points: 0 },
    { name: "sun", points: 0 },
    { name: "construction", points: -3 },
    { name: "rain", points: -4 },
    { name: "taxi", points: 2 },
    { name: "subway", points: 2 },
];

// Game state
let gameState = {
    vibes: INITIAL_VIBES,
    inventory: [],
    sunActive: false,
    sunTimer: 0,
    edibleTimers: [],
    devil: null,
    devilDisabled: false,
    lastDevilSpawn: 0,
    devilSpawnedAt: 0,
    gameOver: false,
    resultText: "",
};

// Helper functions for game state
function isHigh() {
    const now = time();
    gameState.edibleTimers = gameState.edibleTimers.filter(t => now - t < EDIBLE_DURATION);
    return gameState.edibleTimers.length > 0;
}

function applyEdible() {
    gameState.edibleTimers.push(time());
}

function updateSunEffect() {
    if (gameState.sunActive && time() - gameState.sunTimer > SUN_DURATION) {
        gameState.sunActive = false;
    }
}

// ================================
// 4. START SCREEN
// ================================

scene("start", () => {
    add([
        sprite("start", { width: width(), height: height() }),
        pos(0, 0),
    ]);

    add([
        text("Press any key to start", { size: 24 }),
        pos(center().x, height() - 50),
        anchor("center"),
        color(255, 255, 255),
    ]);

    onKeyPress(() => {
        console.log("Transitioning to game scene!"); // Debug log to verify scene transition
        go("game");
    });
});

// ================================
// 5. MAIN GAME SCENE
// ================================

scene("game", () => {
    console.log("Game scene loaded!"); // Debug log to verify scene transition

    let music = play("bgm", {
        volume: 0.5,
        loop: true,
    });

    // Map background
    add([
        sprite("map", { width: mapWidth, height: mapHeight }),
        pos(0, 0),
        z(-1),
    ]);

    // Player (spawn dead center)
    const player = add([
        sprite("player", { width: 64, height: 64 }),
        pos(mapWidth / 2, mapHeight / 2),
        area(),
        body(),
        z(1),
    ]);

    // Popup Text (attached to player position)
    const popupLabel = add([
        text("", { size: 20 }),
        pos(player.pos.add(vec2(0, -70))),
        anchor("center"),
        color(30, 30, 120), // dark blue
    ]);

    popupLabel.hidden = true;

    // Camera follows player
    onUpdate(() => {
        camPos(player.pos);
        popupLabel.pos = player.pos.add(vec2(0, -70)); // always float above player
    });

    // Create UI container with proper transparency
    const uiContainer = add([
        rect(width(), 120),
        pos(0, 0),
        color(0, 0, 0, 0.7),
        fixed(),
        z(99),
    ]);

    // Vibes tracking with enhanced visibility
    const vibesLabel = add([
        text(`Vibes: ${gameState.vibes}`, { 
            size: 30, // Slightly smaller
            font: "Arial",
            width: width() / 3,
        }),
        pos(20, 50), // Move further down
        color(255, 255, 255),
        fixed(),
        z(100),
        "vibesLabel"
    ]);

    // Function to update vibes label
    function updateVibesDisplay() {
        vibesLabel.text = `Vibes: ${gameState.vibes}`;
        vibesLabel.color = gameState.vibes >= WIN_VIBES ? [0, 255, 0] :
                            gameState.vibes <= LOSE_VIBES ? [255, 0, 0] :
                            [255, 255, 255];
    }

    // Call initially
    updateVibesDisplay();

    // Miles (distance) in top right
    let distanceWalked = 0;
    const distanceLabel = add([
        text("Miles: 0.0", { 
            size: 24,
            font: "Arial"
        }),
        pos(width() - 220, 20),
        color(255, 255, 255),
        fixed(),
        z(100),
    ]);

    // Time tracking with enhanced visibility
    let startTime = time();
    const timeLabel = add([
        text("Time: 0:00", { 
            size: 24,
            font: "sans-serif"
        }),
        pos(width() - 250, 60),
        color(255, 255, 255),
        fixed(),
        z(100),
    ]);

    // Add a title at the top
    const titleLabel = add([
        text("NYC Vibes", { 
            size: 36,
            font: "sans-serif"
        }),
        pos(center().x, 20),
        anchor("center"),
        color(255, 255, 255),
        fixed(),
        z(100),
    ]);

    // Update distance in onUpdate
    let lastPos = player.pos.clone();
    onUpdate(() => {
        const dx = Math.abs(player.pos.x - lastPos.x);
        const dy = Math.abs(player.pos.y - lastPos.y);
        const milesX = (dx / mapWidth) * (mapWidth * BLOCK_SIZE_EW);
        const milesY = (dy / mapHeight) * (mapHeight * BLOCK_SIZE_NS);
        const totalMiles = Math.sqrt(milesX * milesX + milesY * milesY);
        distanceWalked += totalMiles;
        distanceLabel.text = `Miles: ${distanceWalked.toFixed(1)}`;
        lastPos = player.pos.clone();

        // Update time
        const elapsed = time() - startTime;
        const minutes = Math.floor(elapsed / 60);
        const seconds = Math.floor(elapsed % 60);
        timeLabel.text = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
    });

    // Player movement
    const speed = 240;
    onKeyDown("left", () => player.move(-speed, 0));
    onKeyDown("right", () => player.move(speed, 0));
    onKeyDown("up", () => player.move(0, -speed));
    onKeyDown("down", () => player.move(0, speed));

    // Clamp player inside map with buffer
    onUpdate(() => {
        const buffer = 50; // Buffer zone to prevent player from going off screen
        player.pos.x = clamp(player.pos.x, buffer, mapWidth - player.width - buffer);
        player.pos.y = clamp(player.pos.y, buffer, mapHeight - player.height - buffer);
    });

    // Load devil sprite before using it
    loadSprite("devil", "static/devil.png", {
        width: 64,
        height: 64
    });
    loadSound("dark", "static/dark.mp3");
    loadSound("boom", "static/boom.wav");

    // Add warning indicator
    const warningIndicator = add([
        text("DEVIL APPROACHING!", { 
            size: 32,
            font: "sans-serif"
        }),
        pos(center().x, 100),
        anchor("center"),
        color(255, 0, 0),
        fixed(),
        z(101)
    ]);
    warningIndicator.hidden = true;

    // Track if grenade has spawned
    let grenadeSpawned = false;
    let gameStartTime = time();

    // Modified spawn logic
    function spawnRandomItem() {
        const now = time();
        const elapsed = now - gameStartTime;
        // Special grenade spawn logic - only once per game, 30% chance
        if (!grenadeSpawned && elapsed >= GRENADE_SPAWN_DELAY && Math.random() < 0.3) {
            grenadeSpawned = true;
            return { name: "grenade", points: 0 };
        }
        // Regular item spawn
        return choose(itemsToSpawn.filter(item => item.name !== "grenade"));
    }

    // Helper function to spawn an item at a given position
    function spawnItem(itemName, points, position) {
        let x, y;
        if (position) {
            x = position.x;
            y = position.y;
        } else {
            x = rand(100, mapWidth - 100);
            y = rand(100, mapHeight - 100);
        }
        const obj = add([
            sprite(itemName, { width: 64, height: 64 }),
            pos(x, y),
            area(),
            z(1),
            { points: points, itemName: itemName },
        ]);
        return obj;
    }

    // Helper function to spawn an item near the center of the map
    function spawnNearCenter(itemName, points) {
        // Center with a small random offset
        const offset = 100;
        const x = (mapWidth / 2) + rand(-offset, offset);
        const y = (mapHeight / 2) + rand(-offset, offset);
        return spawnItem(itemName, points, { x, y });
    }

    // Modified dog spawn logic
    function spawnDog() {
        const dog = spawnItem("dog", 4);
        if (dog) {
            wait(DOG_POOP_TIMER, () => {
                if (dog.exists()) {
                    const poopPos = dog.pos.clone();
                    destroy(dog);
                    spawnItem("poop", -5, poopPos);
                }
            });
        }
    }

    // Modified devil spawn check
    onUpdate(() => {
        const now = time();
        const gameTime = now - gameStartTime;
        
        // Only check for devil spawn after 30 seconds
        if (gameTime < 30) return;
        
        // Show warning before devil spawn
        if (!gameState.devil && !gameState.devilDisabled && 
            now - gameState.lastDevilSpawn > DEVIL_MIN_INTERVAL - DEVIL_WARNING_DURATION && 
            now - gameState.lastDevilSpawn < DEVIL_MIN_INTERVAL && 
            Math.random() < DEVIL_SPAWN_CHANCE) {
            
            warningIndicator.hidden = false;
            warningIndicator.opacity = 1;
            
            // Flash warning
            loop(0.1, () => {
                warningIndicator.opacity = warningIndicator.opacity === 1 ? 0.5 : 1;
            });
            
            // Hide warning after duration
            wait(DEVIL_WARNING_DURATION, () => {
                warningIndicator.hidden = true;
                warningIndicator.opacity = 1;
            });
        }
        
        // Rest of devil spawn logic...
        if (!gameState.devil && !gameState.devilDisabled && 
            now - gameState.lastDevilSpawn > DEVIL_MIN_INTERVAL && 
            Math.random() < DEVIL_SPAWN_CHANCE) {
            
            // Spawn devil
            gameState.devil = add([
                sprite("devil", { width: 64, height: 64 }),
                pos(rand(0, mapWidth - 100), rand(0, mapHeight - 100)),
                area(),
                z(1),
                "devil",
            ]);

            gameState.devilSpawnedAt = now;
            gameState.lastDevilSpawn = now;

            // Play dark music
            gameState.devilMusic = play("dark", {
                volume: 0.5,
                loop: true,
            });
        }

        // Update devil movement
        if (gameState.devil) {
            // Calculate direction to player
            const dx = player.pos.x - gameState.devil.pos.x;
            const dy = player.pos.y - gameState.devil.pos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                // Move devil towards player at DEVIL_SPEED
                const moveX = (dx / dist) * DEVIL_SPEED;
                const moveY = (dy / dist) * DEVIL_SPEED;
                gameState.devil.move(moveX, moveY);
            }

            // Check collision with player
            if (gameState.devil.isColliding(player)) {
                if (gameState.inventory.includes("grenade")) {
                    // Use grenade
                    gameState.inventory = gameState.inventory.filter(item => item !== "grenade");
                    
                    // Flash effect
                    add([
                        rect(width(), height()),
                        pos(0, 0),
                        color(255, 255, 255),
                        fixed(),
                        z(102),
                        lifespan(0.5),
                    ]);

                    play("boom");
                    destroy(gameState.devil);
                    gameState.devil = null;
                    gameState.devilDisabled = true;
                    
                    // Stop devil music
                    if (gameState.devilMusic) {
                        gameState.devilMusic.stop();
                    }
                    
                    // Restore normal music
                    play("bgm", {
                        volume: 0.5,
                        loop: true,
                    });
                } else {
                    // Player caught by devil
                    gameState.vibes -= DEVIL_VIBES_PENALTY;
                    updateVibesDisplay();
                    play("negative");
                    
                    destroy(gameState.devil);
                    gameState.devil = null;
                    
                    // Stop devil music
                    if (gameState.devilMusic) {
                        gameState.devilMusic.stop();
                    }
                    
                    // Restore normal music
                    play("bgm", {
                        volume: 0.5,
                        loop: true,
                    });
                }
            }

            // Check devil lifespan
            if (now - gameState.devilSpawnedAt > DEVIL_LIFESPAN) {
                destroy(gameState.devil);
                gameState.devil = null;
                
                // Stop devil music
                if (gameState.devilMusic) {
                    gameState.devilMusic.stop();
                }
                
                // Restore normal music
                play("bgm", {
                    volume: 0.5,
                    loop: true,
                });
            }
        }
    });

    // Modified initial spawns with more items
    spawnNearCenter("dog", 4);
    spawnNearCenter("coffee", 5);
    spawnNearCenter("pizza", 5);
    spawnNearCenter("pretzel", 4);
    spawnRandomly();

    // ===== Collisions =====

    // Update collision handler for special items
    player.onCollide((obj) => {
        if (obj.points === undefined) return;

        destroy(obj);
        let points = obj.points;
        
        // Apply sun effect
        if (gameState.sunActive && points > 0) {
            points *= 2;
        }

        gameState.vibes += points;
        updateVibesDisplay(); // Update vibes display

        if (obj.points > 0) {
            play("positive");
        } else if (obj.points < 0) {
            play("negative");
        }

        // Handle special items
        if (obj.itemName === "sun") {
            gameState.sunActive = true;
            gameState.sunTimer = time();
            add([
                text("Sunshine boost activated!", { size: 24 }),
                pos(center().x, height() - 100),
                anchor("center"),
                color(255, 255, 0),
                fixed(),
                z(101),
                lifespan(2),
            ]);
        } else if (obj.itemName === "edible") {
            applyEdible();
            add([
                text("Feeling funny...", { size: 24 }),
                pos(center().x, height() - 100),
                anchor("center"),
                color(255, 100, 255),
                fixed(),
                z(101),
                lifespan(2),
            ]);
        } else if (obj.itemName === "grenade") {
            if (!gameState.inventory.includes("grenade")) {
                gameState.inventory.push("grenade");
                inventoryLabel.text = "Inventory: " + gameState.inventory.join(", ");
                add([
                    text("Grenade ready!", { size: 24 }),
                    pos(center().x, height() - 100),
                    anchor("center"),
                    color(255, 0, 0),
                    fixed(),
                    z(101),
                    lifespan(2),
                ]);
            }
        } else if (obj.itemName === "museum") {
            if (!gameState.inventory.includes("map")) {
                gameState.inventory.push("map");
                inventoryLabel.text = "Inventory: " + gameState.inventory.join(", ");
                add([
                    text("Map acquired!", { size: 24 }),
                    pos(center().x, height() - 100),
                    anchor("center"),
                    color(0, 255, 0),
                    fixed(),
                    z(101),
                    lifespan(2),
                ]);
            }
        } else if (obj.itemName === "taxi" || obj.itemName === "subway") {
            add([
                text("Escaped via " + obj.itemName + "!", { size: 24 }),
                pos(center().x, height() - 100),
                anchor("center"),
                color(0, 255, 255),
                fixed(),
                z(101),
                lifespan(2),
            ]);
        }

        if (obj.itemName && cuteMessages[obj.itemName]) {
            popupLabel.text = cuteMessages[obj.itemName];
            popupLabel.hidden = false;
            wait(2, () => {
                popupLabel.hidden = true;
            });
        }
    });

    // ===== Lose Condition =====

    onUpdate(() => {
        updateSunEffect();
        
        if (gameState.vibes >= WIN_VIBES) {
            gameState.gameOver = true;
            gameState.resultText = "win";
            go("win", { vibes: gameState.vibes });
        } else if (gameState.vibes <= LOSE_VIBES) {
            gameState.gameOver = true;
            gameState.resultText = "lose";
            go("lose", { vibes: gameState.vibes });
        }
    });

    // Helper function to spawn random items at random intervals
    function spawnRandomly() {
        function spawnAndSchedule() {
            const item = spawnRandomItem();
            if (item && item.name && item.points !== undefined) {
                spawnItem(item.name, item.points);
            }
            // Schedule next spawn
            const nextTime = rand(ITEM_SPAWN_INTERVAL_MIN, ITEM_SPAWN_INTERVAL_MAX);
            wait(nextTime, spawnAndSchedule);
        }
        spawnAndSchedule();
    }

});

// ================================
// 6. LOSE SCREEN
// ================================

scene("lose", (data) => {
    add([
        text("Final Vibes: " + data.vibes, 32),
        pos(center()),
        anchor("center"),
    ]);

    add([
        text("Press any key to restart", { size: 24 }),
        pos(center().x, height() - 50),
        anchor("center"),
        color(255, 255, 255),
    ]);

    onKeyPress(() => {
        go("start");
    });
});

// Add win scene
scene("win", (data) => {
    add([
        text("You Win! Final Vibes: " + data.vibes, 32),
        pos(center()),
        anchor("center"),
    ]);

    add([
        text("Press any key to restart", { size: 24 }),
        pos(center().x, height() - 50),
        anchor("center"),
        color(255, 255, 255),
    ]);

    onKeyPress(() => {
        go("start");
    });
});

// ================================
// 7. START THE GAME
// ================================

go("start");

</script>
</body>
</html>
