<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NYC Vibes JS</title>
    <link rel="icon" type="image/png" href="static/favicon.png">
    <script src="https://unpkg.com/kaboom@3000/dist/kaboom.js"></script>
    <script src="constants.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
        }
        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
<script>
console.log("Script started!"); // Debug log to verify script execution

// ================================
// 0. GAME CONSTANTS
// ================================

// ================================
// 1. INITIALIZE GAME
// ================================

kaboom({
    width: 1024,  // Increased from 800
    height: 768,  // Increased from 600
    background: [0, 0, 0],
    crisp: true,  // Enable crisp rendering
    pixelDensity: 1,  // Disable high DPI scaling
});

console.log("Kaboom initialized!"); // Debug log to verify Kaboom is running

// ================================
// 2. LOAD ASSETS
// ================================

loadSprite("start", "static/start_screen.jpg");
console.log("Start screen sprite loaded!"); // Debug log to verify asset loading

loadSprite("player", "static/KJK.png");
console.log("Player sprite loaded!"); // Debug log to verify asset loading

loadSprite("map", "static/NYCmap.jpg");
console.log("Map sprite loaded!"); // Debug log to verify asset loading

loadSound("bgm", "static/bg_music.mp3");
console.log("Background music loaded!"); // Debug log to verify asset loading

loadSound("positive", "static/positive.wav");
console.log("Positive sound loaded!"); // Debug log to verify asset loading

loadSound("negative", "static/negative.wav");
console.log("Negative sound loaded!"); // Debug log to verify asset loading

// Item sprites
const itemSprites = [
    "dog", "poop", "pizza", "pretzel", "bagels", "coffee",
    "museum", "tourist", "edible", "grenade", "sun",
    "construction", "rain", "taxi", "subway"
];
for (const spriteName of itemSprites) {
    loadSprite(spriteName, `static/${spriteName}.png`);
}

// ================================
// 3. CUTE MESSAGES
// ================================

const cuteMessages = {
    pizza: "Nothing better than NYC pizza! +5",
    dog: "Who's a good dog? +4",
    pretzel: "Twist and shout! Pretzel +4",
    bagels: "Bagels from NYC are unbeatable! +3",
    coffee: "Fuel for the city grind! +5",
    poop: "Watch your step! Gross! -5",
    museum: "Discovered a hidden gem! +5",
    tourist: "Tourist jam! -4",
    edible: "Feeling funny... +5",
    grenade: "Grenade ready! 0",
    sun: "Sunshine boost activated!",
    construction: "Detour ahead! -3",
    rain: "Rainy day blues. -4",
    taxi: "Caught a cab! +2",
    subway: "Next stop, fun! +2",
};

// Master item list
const itemsToSpawn = [
    { name: "pizza", points: 5 },
    { name: "pretzel", points: 4 },
    { name: "bagels", points: 3 },
    { name: "coffee", points: 5 },
    { name: "museum", points: 5 },
    { name: "tourist", points: -4 },
    { name: "edible", points: 5 },
    { name: "grenade", points: 0 },
    { name: "sun", points: 0 },
    { name: "construction", points: -3 },
    { name: "rain", points: -4 },
    { name: "taxi", points: 2 },
    { name: "subway", points: 2 },
];

// Game state
let gameState = {
    vibes: INITIAL_VIBES,
    inventory: [],
    sunActive: false,
    sunTimer: 0,
    edibleTimers: [],
    devil: null,
    devilDisabled: false,
    lastDevilSpawn: 0,
    devilSpawnedAt: 0,
    gameOver: false,
    resultText: "",
};

// Helper functions for game state
function isHigh() {
    const now = time();
    gameState.edibleTimers = gameState.edibleTimers.filter(t => now - t < EDIBLE_DURATION);
    return gameState.edibleTimers.length > 0;
}

function applyEdible() {
    gameState.edibleTimers.push(time());
}

function updateSunEffect() {
    if (gameState.sunActive && time() - gameState.sunTimer > SUN_DURATION) {
        gameState.sunActive = false;
    }
}

// ================================
// 4. START SCREEN
// ================================

scene("start", () => {
    add([
        sprite("start", { width: width(), height: height() }),
        pos(0, 0),
    ]);

    add([
        text("Press any key to start", { size: 24 }),
        pos(center().x, height() - 50),
        anchor("center"),
        color(255, 255, 255),
    ]);

    onKeyPress(() => {
        console.log("Transitioning to game scene!"); // Debug log to verify scene transition
        go("game");
    });
});

// ================================
// 5. MAIN GAME SCENE
// ================================

scene("game", () => {
    console.log("Game scene loaded!"); // Debug log to verify scene transition

    // Music instance tracking
    let music = null;

    function playMusic(track) {
        if (music) music.stop();
        music = play(track, {
            volume: 0.5,
            loop: true,
        });
    }

    // Start background music
    playMusic("bgm");

    // Map background
    add([
        sprite("map", { width: mapWidth, height: mapHeight }),
        pos(0, 0),
        z(-1),
    ]);

    // Player (spawn dead center)
    const player = add([
        sprite("player", { width: 64, height: 64 }),
        pos(mapWidth / 2, mapHeight / 2),
        area(),
        body(),
        z(1),
    ]);

    // Popup Text (attached to player position)
    const popupLabel = add([
        text("", { size: 20 }),
        pos(player.pos.add(vec2(0, -70))),
        anchor("center"),
        color(30, 30, 120), // dark blue
    ]);

    popupLabel.hidden = true;

    // Camera follows player
    onUpdate(() => {
        camPos(player.pos);
        popupLabel.pos = player.pos.add(vec2(0, -70)); // always float above player
    });

    // Create UI container with proper transparency
    const uiContainer = add([
        rect(width(), 120),
        pos(0, 0),
        color(0, 0, 0, 0.7),
        fixed(),
        z(99),
    ]);

    // Vibes tracking with enhanced visibility
    const vibesLabel = add([
        text(`Vibes: ${gameState.vibes}`, { 
            size: 30, // Slightly smaller
            font: "Arial",
            width: width() / 3,
        }),
        pos(20, 50), // Move further down
        color(255, 255, 255),
        fixed(),
        z(100),
        "vibesLabel"
    ]);

    // Function to update vibes label
    function updateVibesDisplay() {
        vibesLabel.text = `Vibes: ${gameState.vibes}`;
        vibesLabel.color = gameState.vibes >= WIN_VIBES ? [0, 255, 0] :
                            gameState.vibes <= LOSE_VIBES ? [255, 0, 0] :
                            [255, 255, 255];
    }

    // Call initially
    updateVibesDisplay();

    // Miles (distance) in top right
    let distanceWalked = 0;
    const distanceLabel = add([
        text("Miles: 0.0", { 
            size: 24,
            font: "Arial"
        }),
        pos(width() - 220, 20),
        color(255, 255, 255),
        fixed(),
        z(100),
    ]);

    // Time tracking with enhanced visibility
    let startTime = time();
    const timeLabel = add([
        text("Time: 0:00", { 
            size: 24,
            font: "sans-serif"
        }),
        pos(width() - 250, 60),
        color(255, 255, 255),
        fixed(),
        z(100),
    ]);

    // Add a title at the top
    const titleLabel = add([
        text("NYC Vibes", { 
            size: 36,
            font: "sans-serif"
        }),
        pos(center().x, 20),
        anchor("center"),
        color(255, 255, 255),
        fixed(),
        z(100),
    ]);

    // Inventory label (declare in main scope)
    let inventoryLabel = add([
        text("Inventory: " + gameState.inventory.join(", "), {
            size: 24,
            font: "Arial"
        }),
        pos(20, 90),
        color(255, 255, 255),
        fixed(),
        z(100),
        "inventoryLabel"
    ]);

    // Function to update inventory label
    function updateInventoryLabel() {
        inventoryLabel.text = "Inventory: " + gameState.inventory.join(", ");
    }

    // Call initially
    updateInventoryLabel();

    // Update distance in onUpdate
    let lastPos = player.pos.clone();
    onUpdate(() => {
        const dx = Math.abs(player.pos.x - lastPos.x);
        const dy = Math.abs(player.pos.y - lastPos.y);
        const milesX = (dx / mapWidth) * (mapWidth * BLOCK_SIZE_EW);
        const milesY = (dy / mapHeight) * (mapHeight * BLOCK_SIZE_NS);
        const totalMiles = Math.sqrt(milesX * milesX + milesY * milesY);
        distanceWalked += totalMiles;
        distanceLabel.text = `Miles: ${distanceWalked.toFixed(1)}`;
        lastPos = player.pos.clone();

        // Update time
        const elapsed = time() - startTime;
        const minutes = Math.floor(elapsed / 60);
        const seconds = Math.floor(elapsed % 60);
        timeLabel.text = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
    });

    // Player movement
    const speed = 240;
    onKeyDown("left", () => player.move(-speed, 0));
    onKeyDown("right", () => player.move(speed, 0));
    onKeyDown("up", () => player.move(0, -speed));
    onKeyDown("down", () => player.move(0, speed));

    // Clamp player inside map with buffer
    onUpdate(() => {
        const buffer = 50; // Buffer zone to prevent player from going off screen
        player.pos.x = clamp(player.pos.x, buffer, mapWidth - player.width - buffer);
        player.pos.y = clamp(player.pos.y, buffer, mapHeight - player.height - buffer);
    });

    // Load devil sprite before using it
    loadSprite("devil", "static/devil.png", {
        width: 64,
        height: 64
    });
    loadSound("dark", "static/dark.mp3");
    loadSound("boom", "static/boom.wav");

    // Add warning indicator
    const warningIndicator = add([
        text("DEVIL APPROACHING!", { 
            size: 32,
            font: "sans-serif"
        }),
        pos(center().x, 100),
        anchor("center"),
        color(255, 0, 0),
        fixed(),
        z(101)
    ]);
    warningIndicator.hidden = true;

    // Track if grenade has spawned
    let grenadeSpawned = false;
    let gameStartTime = time();

    // Modified spawn logic
    function spawnRandomItem() {
        const now = time();
        const elapsed = now - gameStartTime;
        // Special grenade spawn logic - only once per game, 30% chance
        if (!grenadeSpawned && elapsed >= GRENADE_SPAWN_DELAY && Math.random() < 0.3) {
            grenadeSpawned = true;
            return { name: "grenade", points: 0 };
        }
        // Regular item spawn
        return choose(itemsToSpawn.filter(item => item.name !== "grenade"));
    }

    // Helper function to spawn an item at a given position
    function spawnItem(itemName, points, position) {
        let x, y;
        if (position) {
            x = position.x;
            y = position.y;
        } else {
            x = rand(100, mapWidth - 100);
            y = rand(100, mapHeight - 100);
        }
        const obj = add([
            sprite(itemName, { width: 64, height: 64 }),
            pos(x, y),
            area(),
            z(1),
            { points: points, itemName: itemName },
        ]);
        return obj;
    }

    // Only spawn dog and coffee near center, not on player
    function spawnDogNearCenterNotOnPlayer() {
        const offset = 100;
        let x = (mapWidth / 2) + rand(-offset, offset);
        let y = (mapHeight / 2) + rand(-offset, offset);
        while (Math.abs(x - mapWidth/2) < 40 && Math.abs(y - mapHeight/2) < 40) {
            x = (mapWidth / 2) + rand(-offset, offset);
            y = (mapHeight / 2) + rand(-offset, offset);
        }
        const dog = spawnItem("dog", 4, { x, y });
        if (dog) {
            wait(DOG_POOP_TIMER, () => {
                if (dog.exists()) {
                    const poopPos = dog.pos.clone();
                    destroy(dog);
                    spawnItem("poop", -5, poopPos);
                }
            });
        }
    }

    // Generic version for other items (like coffee)
    function spawnNearCenterNotOnPlayer(itemName, points) {
        const offset = 100;
        let x = (mapWidth / 2) + rand(-offset, offset);
        let y = (mapHeight / 2) + rand(-offset, offset);
        while (Math.abs(x - mapWidth/2) < 40 && Math.abs(y - mapHeight/2) < 40) {
            x = (mapWidth / 2) + rand(-offset, offset);
            y = (mapHeight / 2) + rand(-offset, offset);
        }
        return spawnItem(itemName, points, { x, y });
    }

    spawnDogNearCenterNotOnPlayer();
    spawnNearCenterNotOnPlayer("coffee", 5);

    // Delay all other random spawns until after a short wait (e.g., 2 seconds)
    wait(2, () => {
        spawnRandomly();
    });

    // ===== Collisions =====

    // Update collision handler for special items
    player.onCollide((obj) => {
        if (obj.points === undefined) return;

        destroy(obj);
        let points = obj.points;
        
        // Apply sun effect
        if (gameState.sunActive && points > 0) {
            points *= 2;
        }

        gameState.vibes += points;
        updateVibesDisplay(); // Update vibes display

        if (obj.points > 0) {
            play("positive");
        } else if (obj.points < 0) {
            play("negative");
        }

        // Handle special items
        if (obj.itemName === "sun") {
            gameState.sunActive = true;
            gameState.sunTimer = time();
            add([
                text("Sunshine boost activated!", { size: 24 }),
                pos(center().x, height() - 100),
                anchor("center"),
                color(255, 255, 0),
                fixed(),
                z(101),
                lifespan(2),
            ]);
        } else if (obj.itemName === "edible") {
            applyEdible();
            add([
                text("Feeling funny...", { size: 24 }),
                pos(center().x, height() - 100),
                anchor("center"),
                color(255, 100, 255),
                fixed(),
                z(101),
                lifespan(2),
            ]);
        } else if (obj.itemName === "grenade") {
            if (!gameState.inventory.includes("grenade")) {
                gameState.inventory.push("grenade");
                updateInventoryLabel();
                add([
                    text("Grenade ready!", { size: 24 }),
                    pos(center().x, height() - 100),
                    anchor("center"),
                    color(255, 0, 0),
                    fixed(),
                    z(101),
                    lifespan(2),
                ]);
            }
        } else if (obj.itemName === "museum") {
            if (!gameState.inventory.includes("map")) {
                gameState.inventory.push("map");
                updateInventoryLabel();
                add([
                    text("Map acquired!", { size: 24 }),
                    pos(center().x, height() - 100),
                    anchor("center"),
                    color(0, 255, 0),
                    fixed(),
                    z(101),
                    lifespan(2),
                ]);
            }
        } else if (obj.itemName === "taxi" || obj.itemName === "subway") {
            add([
                text("Escaped via " + obj.itemName + "!", { size: 24 }),
                pos(center().x, height() - 100),
                anchor("center"),
                color(0, 255, 255),
                fixed(),
                z(101),
                lifespan(2),
            ]);
        }

        if (obj.itemName && cuteMessages[obj.itemName]) {
            popupLabel.text = cuteMessages[obj.itemName];
            popupLabel.hidden = false;
            wait(2, () => {
                popupLabel.hidden = true;
            });
        }
    });

    // ===== Lose Condition =====

    onUpdate(() => {
        updateSunEffect();
        
        if (gameState.vibes >= WIN_VIBES) {
            gameState.gameOver = true;
            gameState.resultText = "win";
            go("win", { vibes: gameState.vibes });
        } else if (gameState.vibes <= LOSE_VIBES) {
            gameState.gameOver = true;
            gameState.resultText = "lose";
            go("lose", { vibes: gameState.vibes });
        }
    });

    // Helper function to spawn random items at random intervals
    function spawnRandomly() {
        function spawnAndSchedule() {
            const item = spawnRandomItem();
            if (item && item.name && item.points !== undefined) {
                spawnItem(item.name, item.points);
            }
            // Schedule next spawn
            const nextTime = rand(ITEM_SPAWN_INTERVAL_MIN, ITEM_SPAWN_INTERVAL_MAX);
            wait(nextTime, spawnAndSchedule);
        }
        spawnAndSchedule();
    }

});

// ================================
// 6. LOSE SCREEN
// ================================

scene("lose", (data) => {
    add([
        text("Final Vibes: " + data.vibes, 32),
        pos(center()),
        anchor("center"),
    ]);

    add([
        text("Press any key to restart", { size: 24 }),
        pos(center().x, height() - 50),
        anchor("center"),
        color(255, 255, 255),
    ]);

    onKeyPress(() => {
        go("start");
    });
});

// Add win scene
scene("win", (data) => {
    add([
        text("You Win! Final Vibes: " + data.vibes, 32),
        pos(center()),
        anchor("center"),
    ]);

    add([
        text("Press any key to restart", { size: 24 }),
        pos(center().x, height() - 50),
        anchor("center"),
        color(255, 255, 255),
    ]);

    onKeyPress(() => {
        go("start");
    });
});

// ================================
// 7. START THE GAME
// ================================

go("start");

</script>
</body>
</html>
